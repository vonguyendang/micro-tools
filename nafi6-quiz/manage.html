<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qu·∫£n L√Ω Ng√¢n H√†ng C√¢u H·ªèi</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="quiz-container">
        <header>
            <h1>‚öôÔ∏è Qu·∫£n L√Ω Ng√¢n H√†ng C√¢u H·ªèi</h1>
            <p style="text-align: center; color: #dc3545; font-weight: 500;">
                *<b>S·ª≠a/X√≥a</b> c√¢u h·ªèi g·ªëc s·∫Ω c·∫≠p nh·∫≠t file <b>data.json</b>.<br>
                *<b>Th√™m/S·ª≠a/X√≥a</b> c√¢u h·ªèi m·ªõi s·∫Ω c·∫≠p nh·∫≠t v√† <b>t·ª± ƒë·ªông ƒë√°nh s·ªë l·∫°i</b> file <b>add-quiz.json</b>.*
            </p>
        </header>

        <div id="admin-password-modal" class="modal">
            <div class="modal-content">
                <span class="close-btn" onclick="window.close()">&times;</span>
                <h3>üîê Nh·∫≠p M·∫≠t kh·∫©u Qu·∫£n tr·ªã</h3>
                <label for="adminPasswordInput">M·∫≠t kh·∫©u:</label>
                <input type="password" id="adminPasswordInput" placeholder="B√≠ m·∫≠t..." onkeydown="if(event.key === 'Enter') checkAdminPassword()">
                <p id="password-error" style="color: red; margin-top: 10px;" class="hidden"></p>
                <button class="btn btn-primary" onclick="checkAdminPassword()">Truy C·∫≠p</button>
            </div>
        </div>

        <section id="manage-questions-section" class="hidden">
            <div class="add-question-form-container">
                <h3 id="add-edit-form-title">Th√™m C√¢u H·ªèi M·ªõi</h3>
                <form id="add-question-form">
                    <input type="hidden" id="current-question-id">
                    <div class="form-group">
                        <label for="new-question-text">N·ªôi dung C√¢u h·ªèi:</label>
                        <textarea id="new-question-text" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="new-answer-a">ƒê√°p √°n A:</label>
                        <input type="text" id="new-answer-a" required>
                    </div>
                    <div class="form-group">
                        <label for="new-answer-b">ƒê√°p √°n B:</label>
                        <input type="text" id="new-answer-b" required>
                    </div>
                    <div class="form-group">
                        <label for="new-answer-c">ƒê√°p √°n C:</label>
                        <input type="text" id="new-answer-c" required>
                    </div>
                    <div class="form-group">
                        <label for="new-answer-d">ƒê√°p √°n D:</label>
                        <input type="text" id="new-answer-d" required>
                    </div>
                    <div class="form-group">
                        <label for="correct-answer-key">ƒê√°p √°n ƒê√∫ng (A, B, C, D):</label>
                        <select id="correct-answer-key" required>
                            <option value="A">A</option>
                            <option value="B">B</option>
                            <option value="C">C</option>
                            <option value="D">D</option>
                        </select>
                    </div>
                    <button type="submit" class="btn btn-success" id="save-question-btn">L∆∞u C√¢u H·ªèi</button>
                    <button type="button" class="btn btn-secondary" id="cancel-edit-btn" style="display: none;">H·ªßy Ch·ªânh S·ª≠a</button>
                </form>
            </div>
            
            <hr>
            
            <h3>Danh s√°ch Ng√¢n H√†ng C√¢u H·ªèi (<span id="total-questions"></span> c√¢u)</h3>
            
            <div class="form-group search-container">
                <input type="text" id="search-input" placeholder="Nh·∫≠p t·ª´ kh√≥a ho·∫∑c ID c√¢u h·ªèi ƒë·ªÉ t√¨m ki·∫øm..." onkeyup="filterQuestions()">
            </div>
            
            <div id="question-bank-list">
                </div>
        </section>
        
    </div>

    <script>
        const ADMIN_PASSWORD = 'Bimat@123';
        const SAVE_ENDPOINT = './save-quiz-data.php';

        const adminPasswordModal = document.getElementById('admin-password-modal');
        const manageSection = document.getElementById('manage-questions-section');
        const questionBankList = document.getElementById('question-bank-list');
        const addQuestionForm = document.getElementById('add-question-form');
        const addEditFormTitle = document.getElementById('add-edit-form-title');
        const saveQuestionBtn = document.getElementById('save-question-btn');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const searchInput = document.getElementById('search-input');

        let originalQuestions = [];
        let addedQuestions = [];
        let isEditing = false;

        async function loadAndSeparateQuestions() {
            try {
                const [originalRes, addedRes] = await Promise.all([
                    fetch('data.json').catch(e => ({ ok: false, json: () => Promise.resolve([]) })),
                    fetch('add-quiz.json').catch(e => ({ ok: false, text: () => Promise.resolve("[]") }))
                ]);

                originalQuestions = originalRes.ok ? await originalRes.json() : [];
                
                let addedData = [];
                if (addedRes.ok) {
                    const addedText = await addedRes.text();
                    if (addedText && addedText.trim() !== "" && addedText.trim() !== "[]") {
                        addedData = JSON.parse(addedText);
                    }
                }
                addedQuestions = Array.isArray(addedData) ? addedData : [];

            } catch (error) {
                console.error("L·ªói khi t·∫£i d·ªØ li·ªáu c√¢u h·ªèi:", error);
                questionBankList.innerHTML = `<p style="color: red; text-align: center;">Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra file JSON v√† console.</p>`;
            }
        }
        
        // *** H√ÄM L∆ØU ƒê√É C·∫¨P NH·∫¨T LOGIC T·ª∞ ƒê·ªòNG ƒê√ÅNH S·ªê ***
        async function saveAllChangesToServer() {
            // 1. T√¨m ID l·ªõn nh·∫•t t·ª´ file g·ªëc
            const maxIdOriginal = originalQuestions.length > 0
                ? Math.max(...originalQuestions.map(q => q.id))
                : 0;

            // 2. S·∫Øp x·∫øp v√† ƒë√°nh s·ªë l·∫°i TO√ÄN B·ªò c√¢u h·ªèi th√™m m·ªõi ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh li√™n ti·∫øp
            const renumberedAdded = addedQuestions
                .sort((a, b) => (a.tempId || a.id) - (b.tempId || b.id)) // S·∫Øp x·∫øp theo th·ª© t·ª± th√™m/s·ª≠a
                .map((question, index) => {
                    const { tempId, ...rest } = question; // Lo·∫°i b·ªè ID t·∫°m th·ªùi
                    return {
                        ...rest,
                        id: maxIdOriginal + 1 + index // G√°n ID m·ªõi, tu·∫ßn t·ª±
                    };
                });
            
            try {
                const response = await fetch(SAVE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original: originalQuestions,
                        added: renumberedAdded // G·ª≠i danh s√°ch ƒë√£ ƒë∆∞·ª£c ƒë√°nh s·ªë l·∫°i
                    })
                });
                
                if (!response.ok) throw new Error(`Server tr·∫£ v·ªÅ l·ªói: ${response.status}`);
                const result = await response.json();
                
                if (result.success) {
                    alert(`‚úÖ Thao t√°c th√†nh c√¥ng. ${result.message}`);
                    await loadAndSeparateQuestions();
                    filterQuestions();
                    return true;
                } else {
                    alert(`‚ùå L·ªói Server: ${result.message}`);
                    return false;
                }
            } catch (e) {
                console.error("L·ªói khi g·ª≠i d·ªØ li·ªáu:", e);
                alert("‚ùå L·ªói K·∫øt N·ªëi: Kh√¥ng th·ªÉ g·ª≠i d·ªØ li·ªáu ƒë·∫øn server.");
                return false;
            }
        }
        
        function getDisplayList() {
            const questionMap = new Map();
            originalQuestions.forEach(q => questionMap.set(q.id, { ...q, source: 'original' }));
            addedQuestions.forEach(q => questionMap.set(q.id, { ...q, source: 'added' }));
            return Array.from(questionMap.values());
        }

        function renderQuestionBank(questionsToRender) {
            document.getElementById('total-questions').textContent = questionsToRender.length;
            
            if (questionsToRender.length === 0 && searchInput.value.trim()) {
                questionBankList.innerHTML = `<p style="color: #dc3545; text-align: center;">Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi n√†o kh·ªõp.</p>`;
                return;
            }

            questionBankList.innerHTML = questionsToRender.map((q) => {
                const sourceTag = q.source === 'added'
                    ? ' <span style="color:#007bff; font-weight: bold;">(Th√™m m·ªõi)</span>'
                    : ' <span style="color:#6c757d; font-weight: bold;">(G·ªëc)</span>';

                const answerOptions = Object.keys(q.answers).map(key => {
                    const isCorrect = key === q.correctAnswer;
                    return `<div class="q-answer">${key}. ${q.answers[key]} ${isCorrect ? '<b>(ƒê√∫ng)</b>' : ''}</div>`;
                }).join('');

                const managementButtons = `
                    <div style="margin-top: 10px;">
                        <button class="btn btn-info btn-sm" onclick="openEditModal(${q.id})">S·ª≠a</button>
                        <button class="btn btn-danger btn-sm" onclick="deleteQuestion(${q.id})">X√≥a</button>
                    </div>`;

                return `
                    <div class="question-bank-item" data-question-id="${q.id}">
                        <p class="q-number"><b>ID: ${q.id}</b>${sourceTag}</p>
                        <p class="q-text">${q.question}</p>
                        ${answerOptions}
                        ${managementButtons}
                    </div>`;
            }).join('');
        }
        
        window.filterQuestions = () => {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const displayList = getDisplayList();
            
            const filtered = searchTerm ? displayList.filter(q => 
                q.question.toLowerCase().includes(searchTerm) || String(q.id) === searchTerm
            ) : displayList;

            renderQuestionBank(filtered.sort((a, b) => a.id - b.id));
        };
        
        window.openEditModal = (questionId) => {
            const displayList = getDisplayList();
            const questionToEdit = displayList.find(q => q.id === questionId);
            if (!questionToEdit) return;

            isEditing = true;
            addEditFormTitle.textContent = "Ch·ªânh S·ª≠a C√¢u H·ªèi (ID: " + questionId + ")";
            saveQuestionBtn.textContent = "C·∫≠p Nh·∫≠t C√¢u H·ªèi";
            cancelEditBtn.style.display = 'inline-block';

            document.getElementById('current-question-id').value = questionToEdit.id;
            document.getElementById('new-question-text').value = questionToEdit.question;
            document.getElementById('new-answer-a').value = questionToEdit.answers.A;
            document.getElementById('new-answer-b').value = questionToEdit.answers.B;
            document.getElementById('new-answer-c').value = questionToEdit.answers.C;
            document.getElementById('new-answer-d').value = questionToEdit.answers.D;
            document.getElementById('correct-answer-key').value = questionToEdit.correctAnswer;
            
            manageSection.scrollIntoView({ behavior: 'smooth' });
        };
        
        window.deleteQuestion = async (questionId) => {
            if (!confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA Vƒ®NH VI·ªÑN c√¢u h·ªèi (ID: ${questionId})?`)) return;

            originalQuestions = originalQuestions.filter(q => q.id !== questionId);
            addedQuestions = addedQuestions.filter(q => q.id !== questionId);
            
            await saveAllChangesToServer();
        };
        
        function cancelEdit() {
            isEditing = false;
            addEditFormTitle.textContent = "Th√™m C√¢u H·ªèi M·ªõi";
            saveQuestionBtn.textContent = "L∆∞u C√¢u H·ªèi";
            cancelEditBtn.style.display = 'none';
            addQuestionForm.reset();
            document.getElementById('current-question-id').value = '';
        }

        cancelEditBtn.addEventListener('click', cancelEdit);

        addQuestionForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const newQuestionData = {
                question: document.getElementById('new-question-text').value.trim().replace(/\n/g, ' '),
                answers: {
                    A: document.getElementById('new-answer-a').value.trim(),
                    B: document.getElementById('new-answer-b').value.trim(),
                    C: document.getElementById('new-answer-c').value.trim(),
                    D: document.getElementById('new-answer-d').value.trim(),
                },
                correctAnswer: document.getElementById('correct-answer-key').value,
            };

            if (isEditing) {
                const id = parseInt(document.getElementById('current-question-id').value);
                let wasInAdded = addedQuestions.some(q => q.id === id);
                if (wasInAdded) {
                    let index = addedQuestions.findIndex(q => q.id === id);
                    addedQuestions[index] = { ...addedQuestions[index], ...newQuestionData };
                } else {
                    let index = originalQuestions.findIndex(q => q.id === id);
                    if (index > -1) {
                         originalQuestions[index] = { ...originalQuestions[index], ...newQuestionData };
                    }
                }
            } else {
                // Th√™m c√¢u h·ªèi m·ªõi v√†o danh s√°ch 'added' v·ªõi m·ªôt ID t·∫°m th·ªùi ƒë·ªÉ s·∫Øp x·∫øp
                addedQuestions.push({ tempId: Date.now(), ...newQuestionData });
            }

            await saveAllChangesToServer();
            cancelEdit();
        });
        
        window.onload = function() {
            document.getElementById('adminPasswordInput').focus();
        };

        async function checkAdminPassword() {
            const enteredPassword = document.getElementById('adminPasswordInput').value.trim();
            const errorMessage = document.getElementById('password-error');
            if (enteredPassword === ADMIN_PASSWORD) {
                errorMessage.classList.add('hidden');
                await loadAndSeparateQuestions();
                adminPasswordModal.classList.add('hidden');
                manageSection.classList.remove('hidden');
                filterQuestions();
            } else {
                errorMessage.textContent = 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng.';
                errorMessage.classList.remove('hidden');
            }
        }
        window.checkAdminPassword = checkAdminPassword;
    </script>
</body>
</html>